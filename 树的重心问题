# 首先了解什么是树的重心，我们设u为一颗树的重心，那么对于这棵树，如果以u为根节点的话，这颗树的最大子树的节点之和最小，一颗树可以有多个重心
# 树的重心的性质：
~ 树上所有的点到树的重心的距离之和是最短的，如果有多个重心，那么这个和相等
~ 插入或者删除一个点，树的重心最多移动一个单位
~ 若添加一条边连接两棵树，那么新树的重心一定在两颗树的重心的路径上

# 下面我们来看一下应用，作者的第一个例题是LG-P1364，这个题目的n给的是100，可以用floyd解决，但是如果n给到更大就会tle，所以用树的重心就可以O(n)解决本题
// 我们给出这个题目核心函数的源代码，做其他题目是根据具体情况进行修改：

sz[u] 表示以u为根的子树的大小，也就是节点数，f[u] 则表示以u为根的总距离
因为洛谷的这道题设计边的权重问题，对于正常以及普适的情况，只需要将w[u]看成1即可
void dfs(int u,int fa,int dep)
{
    sz[u] = w[u];
    for(auto t : v[u])
    {
        if(t == fa) continue;
        dfs(t,u,dep + 1);
        sz[u] += sz[t];
    }
    f[1] += w[u] * dep;
}

void dp(int u,int fa)
{
    for(auto t : v[u])
    {
        if(t == fa) continue;
        f[t] = f[u] - sz[t] + sz[1] - sz[t];
        dp(t,u);
    }
    ans = min(ans,f[u]);
}
